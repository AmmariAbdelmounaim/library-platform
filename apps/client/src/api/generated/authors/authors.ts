/**
 * Generated by orval v8.0.0-rc.2 üç∫
 * Do not edit manually.
 * Library Platform API
 * API documentation for the Library Platform
 * OpenAPI spec version: 1.0
 */
import { useMutation, useQuery } from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult,
} from '@tanstack/react-query';

import type {
  AuthorResponseDto,
  AuthorWithBooksDto,
  CreateAuthorDto,
  UpdateAuthorDto,
} from '.././model';

import { customInstance } from '../../axios-instance';
import type { ErrorType } from '../../axios-instance';

type AwaitedInput<T> = PromiseLike<T> | T;

type Awaited<O> = O extends AwaitedInput<infer T> ? T : never;

type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];

/**
 * Create a new author. This operation is restricted to users with ADMIN role only.
 * @summary Create a new author
 */
export type authorsControllerCreateResponse201 = {
  data: AuthorResponseDto;
  status: 201;
};

export type authorsControllerCreateResponse400 = {
  data: void;
  status: 400;
};

export type authorsControllerCreateResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerCreateResponse403 = {
  data: void;
  status: 403;
};

export type authorsControllerCreateResponseSuccess =
  authorsControllerCreateResponse201 & {
    headers: Headers;
  };
export type authorsControllerCreateResponseError = (
  | authorsControllerCreateResponse400
  | authorsControllerCreateResponse401
  | authorsControllerCreateResponse403
) & {
  headers: Headers;
};

export type authorsControllerCreateResponse =
  | authorsControllerCreateResponseSuccess
  | authorsControllerCreateResponseError;

export const getAuthorsControllerCreateUrl = () => {
  return `/api/authors`;
};

export const authorsControllerCreate = async (
  createAuthorDto: CreateAuthorDto,
  options?: RequestInit,
): Promise<authorsControllerCreateResponse> => {
  return customInstance<authorsControllerCreateResponse>(
    getAuthorsControllerCreateUrl(),
    {
      ...options,
      method: 'POST',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(createAuthorDto),
    },
  );
};

export const getAuthorsControllerCreateMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorsControllerCreate>>,
    TError,
    { data: CreateAuthorDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authorsControllerCreate>>,
  TError,
  { data: CreateAuthorDto },
  TContext
> => {
  const mutationKey = ['authorsControllerCreate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authorsControllerCreate>>,
    { data: CreateAuthorDto }
  > = (props) => {
    const { data } = props ?? {};

    return authorsControllerCreate(data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthorsControllerCreateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerCreate>>
>;
export type AuthorsControllerCreateMutationBody = CreateAuthorDto;
export type AuthorsControllerCreateMutationError = ErrorType<void>;

/**
 * @summary Create a new author
 */
export const useAuthorsControllerCreate = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorsControllerCreate>>,
    TError,
    { data: CreateAuthorDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authorsControllerCreate>>,
  TError,
  { data: CreateAuthorDto },
  TContext
> => {
  const mutationOptions = getAuthorsControllerCreateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Retrieve a list of all authors. This operation is restricted to users with ADMIN role only.
 * @summary Get all authors
 */
export type authorsControllerFindAllResponse200 = {
  data: AuthorResponseDto[];
  status: 200;
};

export type authorsControllerFindAllResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerFindAllResponse403 = {
  data: void;
  status: 403;
};

export type authorsControllerFindAllResponseSuccess =
  authorsControllerFindAllResponse200 & {
    headers: Headers;
  };
export type authorsControllerFindAllResponseError = (
  | authorsControllerFindAllResponse401
  | authorsControllerFindAllResponse403
) & {
  headers: Headers;
};

export type authorsControllerFindAllResponse =
  | authorsControllerFindAllResponseSuccess
  | authorsControllerFindAllResponseError;

export const getAuthorsControllerFindAllUrl = () => {
  return `/api/authors`;
};

export const authorsControllerFindAll = async (
  options?: RequestInit,
): Promise<authorsControllerFindAllResponse> => {
  return customInstance<authorsControllerFindAllResponse>(
    getAuthorsControllerFindAllUrl(),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getAuthorsControllerFindAllQueryKey = () => {
  return [`/api/authors`] as const;
};

export const getAuthorsControllerFindAllQueryOptions = <
  TData = Awaited<ReturnType<typeof authorsControllerFindAll>>,
  TError = ErrorType<void>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof authorsControllerFindAll>>,
    TError,
    TData
  >;
  request?: SecondParameter<typeof customInstance>;
}) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthorsControllerFindAllQueryKey();

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authorsControllerFindAll>>
  > = ({ signal }) => authorsControllerFindAll({ signal, ...requestOptions });

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<
    Awaited<ReturnType<typeof authorsControllerFindAll>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AuthorsControllerFindAllQueryResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerFindAll>>
>;
export type AuthorsControllerFindAllQueryError = ErrorType<void>;

/**
 * @summary Get all authors
 */

export function useAuthorsControllerFindAll<
  TData = Awaited<ReturnType<typeof authorsControllerFindAll>>,
  TError = ErrorType<void>,
>(options?: {
  query?: UseQueryOptions<
    Awaited<ReturnType<typeof authorsControllerFindAll>>,
    TError,
    TData
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAuthorsControllerFindAllQueryOptions(options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve all authors who wrote a specific book. Requires authentication.
 * @summary Get authors by book ID
 */
export type authorsControllerFindByBookIdResponse200 = {
  data: AuthorResponseDto[];
  status: 200;
};

export type authorsControllerFindByBookIdResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerFindByBookIdResponse404 = {
  data: void;
  status: 404;
};

export type authorsControllerFindByBookIdResponseSuccess =
  authorsControllerFindByBookIdResponse200 & {
    headers: Headers;
  };
export type authorsControllerFindByBookIdResponseError = (
  | authorsControllerFindByBookIdResponse401
  | authorsControllerFindByBookIdResponse404
) & {
  headers: Headers;
};

export type authorsControllerFindByBookIdResponse =
  | authorsControllerFindByBookIdResponseSuccess
  | authorsControllerFindByBookIdResponseError;

export const getAuthorsControllerFindByBookIdUrl = (bookId: number) => {
  return `/api/authors/by-book/${bookId}`;
};

export const authorsControllerFindByBookId = async (
  bookId: number,
  options?: RequestInit,
): Promise<authorsControllerFindByBookIdResponse> => {
  return customInstance<authorsControllerFindByBookIdResponse>(
    getAuthorsControllerFindByBookIdUrl(bookId),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getAuthorsControllerFindByBookIdQueryKey = (bookId?: number) => {
  return [`/api/authors/by-book/${bookId}`] as const;
};

export const getAuthorsControllerFindByBookIdQueryOptions = <
  TData = Awaited<ReturnType<typeof authorsControllerFindByBookId>>,
  TError = ErrorType<void>,
>(
  bookId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof authorsControllerFindByBookId>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthorsControllerFindByBookIdQueryKey(bookId);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authorsControllerFindByBookId>>
  > = ({ signal }) =>
    authorsControllerFindByBookId(bookId, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!bookId,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof authorsControllerFindByBookId>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AuthorsControllerFindByBookIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerFindByBookId>>
>;
export type AuthorsControllerFindByBookIdQueryError = ErrorType<void>;

/**
 * @summary Get authors by book ID
 */

export function useAuthorsControllerFindByBookId<
  TData = Awaited<ReturnType<typeof authorsControllerFindByBookId>>,
  TError = ErrorType<void>,
>(
  bookId: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof authorsControllerFindByBookId>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAuthorsControllerFindByBookIdQueryOptions(
    bookId,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Retrieve all books written by a specific author. Requires authentication.
 * @summary Get books written by an author
 */
export type authorsControllerFindBooksByAuthorIdResponse200 = {
  data: AuthorWithBooksDto;
  status: 200;
};

export type authorsControllerFindBooksByAuthorIdResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerFindBooksByAuthorIdResponse404 = {
  data: void;
  status: 404;
};

export type authorsControllerFindBooksByAuthorIdResponseSuccess =
  authorsControllerFindBooksByAuthorIdResponse200 & {
    headers: Headers;
  };
export type authorsControllerFindBooksByAuthorIdResponseError = (
  | authorsControllerFindBooksByAuthorIdResponse401
  | authorsControllerFindBooksByAuthorIdResponse404
) & {
  headers: Headers;
};

export type authorsControllerFindBooksByAuthorIdResponse =
  | authorsControllerFindBooksByAuthorIdResponseSuccess
  | authorsControllerFindBooksByAuthorIdResponseError;

export const getAuthorsControllerFindBooksByAuthorIdUrl = (id: number) => {
  return `/api/authors/${id}/books`;
};

export const authorsControllerFindBooksByAuthorId = async (
  id: number,
  options?: RequestInit,
): Promise<authorsControllerFindBooksByAuthorIdResponse> => {
  return customInstance<authorsControllerFindBooksByAuthorIdResponse>(
    getAuthorsControllerFindBooksByAuthorIdUrl(id),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getAuthorsControllerFindBooksByAuthorIdQueryKey = (
  id?: number,
) => {
  return [`/api/authors/${id}/books`] as const;
};

export const getAuthorsControllerFindBooksByAuthorIdQueryOptions = <
  TData = Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>,
  TError = ErrorType<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ??
    getAuthorsControllerFindBooksByAuthorIdQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>
  > = ({ signal }) =>
    authorsControllerFindBooksByAuthorId(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AuthorsControllerFindBooksByAuthorIdQueryResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>
>;
export type AuthorsControllerFindBooksByAuthorIdQueryError = ErrorType<void>;

/**
 * @summary Get books written by an author
 */

export function useAuthorsControllerFindBooksByAuthorId<
  TData = Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>,
  TError = ErrorType<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof authorsControllerFindBooksByAuthorId>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAuthorsControllerFindBooksByAuthorIdQueryOptions(
    id,
    options,
  );

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Get author information by ID including all books written by this author. Requires authentication.
 * @summary Get author by ID
 */
export type authorsControllerFindOneResponse200 = {
  data: AuthorWithBooksDto;
  status: 200;
};

export type authorsControllerFindOneResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerFindOneResponse404 = {
  data: void;
  status: 404;
};

export type authorsControllerFindOneResponseSuccess =
  authorsControllerFindOneResponse200 & {
    headers: Headers;
  };
export type authorsControllerFindOneResponseError = (
  | authorsControllerFindOneResponse401
  | authorsControllerFindOneResponse404
) & {
  headers: Headers;
};

export type authorsControllerFindOneResponse =
  | authorsControllerFindOneResponseSuccess
  | authorsControllerFindOneResponseError;

export const getAuthorsControllerFindOneUrl = (id: number) => {
  return `/api/authors/${id}`;
};

export const authorsControllerFindOne = async (
  id: number,
  options?: RequestInit,
): Promise<authorsControllerFindOneResponse> => {
  return customInstance<authorsControllerFindOneResponse>(
    getAuthorsControllerFindOneUrl(id),
    {
      ...options,
      method: 'GET',
    },
  );
};

export const getAuthorsControllerFindOneQueryKey = (id?: number) => {
  return [`/api/authors/${id}`] as const;
};

export const getAuthorsControllerFindOneQueryOptions = <
  TData = Awaited<ReturnType<typeof authorsControllerFindOne>>,
  TError = ErrorType<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof authorsControllerFindOne>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  },
) => {
  const { query: queryOptions, request: requestOptions } = options ?? {};

  const queryKey =
    queryOptions?.queryKey ?? getAuthorsControllerFindOneQueryKey(id);

  const queryFn: QueryFunction<
    Awaited<ReturnType<typeof authorsControllerFindOne>>
  > = ({ signal }) =>
    authorsControllerFindOne(id, { signal, ...requestOptions });

  return {
    queryKey,
    queryFn,
    enabled: !!id,
    ...queryOptions,
  } as UseQueryOptions<
    Awaited<ReturnType<typeof authorsControllerFindOne>>,
    TError,
    TData
  > & { queryKey: QueryKey };
};

export type AuthorsControllerFindOneQueryResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerFindOne>>
>;
export type AuthorsControllerFindOneQueryError = ErrorType<void>;

/**
 * @summary Get author by ID
 */

export function useAuthorsControllerFindOne<
  TData = Awaited<ReturnType<typeof authorsControllerFindOne>>,
  TError = ErrorType<void>,
>(
  id: number,
  options?: {
    query?: UseQueryOptions<
      Awaited<ReturnType<typeof authorsControllerFindOne>>,
      TError,
      TData
    >;
    request?: SecondParameter<typeof customInstance>;
  },
): UseQueryResult<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getAuthorsControllerFindOneQueryOptions(id, options);

  const query = useQuery(queryOptions) as UseQueryResult<TData, TError> & {
    queryKey: QueryKey;
  };

  query.queryKey = queryOptions.queryKey;

  return query;
}

/**
 * Update author information by ID. This operation is restricted to users with ADMIN role only.
 * @summary Update author by ID
 */
export type authorsControllerUpdateResponse200 = {
  data: AuthorResponseDto;
  status: 200;
};

export type authorsControllerUpdateResponse400 = {
  data: void;
  status: 400;
};

export type authorsControllerUpdateResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerUpdateResponse403 = {
  data: void;
  status: 403;
};

export type authorsControllerUpdateResponse404 = {
  data: void;
  status: 404;
};

export type authorsControllerUpdateResponseSuccess =
  authorsControllerUpdateResponse200 & {
    headers: Headers;
  };
export type authorsControllerUpdateResponseError = (
  | authorsControllerUpdateResponse400
  | authorsControllerUpdateResponse401
  | authorsControllerUpdateResponse403
  | authorsControllerUpdateResponse404
) & {
  headers: Headers;
};

export type authorsControllerUpdateResponse =
  | authorsControllerUpdateResponseSuccess
  | authorsControllerUpdateResponseError;

export const getAuthorsControllerUpdateUrl = (id: number) => {
  return `/api/authors/${id}`;
};

export const authorsControllerUpdate = async (
  id: number,
  updateAuthorDto: UpdateAuthorDto,
  options?: RequestInit,
): Promise<authorsControllerUpdateResponse> => {
  return customInstance<authorsControllerUpdateResponse>(
    getAuthorsControllerUpdateUrl(id),
    {
      ...options,
      method: 'PATCH',
      headers: { 'Content-Type': 'application/json', ...options?.headers },
      body: JSON.stringify(updateAuthorDto),
    },
  );
};

export const getAuthorsControllerUpdateMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorsControllerUpdate>>,
    TError,
    { id: number; data: UpdateAuthorDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authorsControllerUpdate>>,
  TError,
  { id: number; data: UpdateAuthorDto },
  TContext
> => {
  const mutationKey = ['authorsControllerUpdate'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authorsControllerUpdate>>,
    { id: number; data: UpdateAuthorDto }
  > = (props) => {
    const { id, data } = props ?? {};

    return authorsControllerUpdate(id, data, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthorsControllerUpdateMutationResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerUpdate>>
>;
export type AuthorsControllerUpdateMutationBody = UpdateAuthorDto;
export type AuthorsControllerUpdateMutationError = ErrorType<void>;

/**
 * @summary Update author by ID
 */
export const useAuthorsControllerUpdate = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorsControllerUpdate>>,
    TError,
    { id: number; data: UpdateAuthorDto },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authorsControllerUpdate>>,
  TError,
  { id: number; data: UpdateAuthorDto },
  TContext
> => {
  const mutationOptions = getAuthorsControllerUpdateMutationOptions(options);

  return useMutation(mutationOptions);
};
/**
 * Delete an author by ID. This operation is restricted to users with ADMIN role only.
 * @summary Delete author by ID
 */
export type authorsControllerRemoveResponse204 = {
  data: void;
  status: 204;
};

export type authorsControllerRemoveResponse401 = {
  data: void;
  status: 401;
};

export type authorsControllerRemoveResponse403 = {
  data: void;
  status: 403;
};

export type authorsControllerRemoveResponse404 = {
  data: void;
  status: 404;
};

export type authorsControllerRemoveResponseSuccess =
  authorsControllerRemoveResponse204 & {
    headers: Headers;
  };
export type authorsControllerRemoveResponseError = (
  | authorsControllerRemoveResponse401
  | authorsControllerRemoveResponse403
  | authorsControllerRemoveResponse404
) & {
  headers: Headers;
};

export type authorsControllerRemoveResponse =
  | authorsControllerRemoveResponseSuccess
  | authorsControllerRemoveResponseError;

export const getAuthorsControllerRemoveUrl = (id: number) => {
  return `/api/authors/${id}`;
};

export const authorsControllerRemove = async (
  id: number,
  options?: RequestInit,
): Promise<authorsControllerRemoveResponse> => {
  return customInstance<authorsControllerRemoveResponse>(
    getAuthorsControllerRemoveUrl(id),
    {
      ...options,
      method: 'DELETE',
    },
  );
};

export const getAuthorsControllerRemoveMutationOptions = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorsControllerRemove>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationOptions<
  Awaited<ReturnType<typeof authorsControllerRemove>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationKey = ['authorsControllerRemove'];
  const { mutation: mutationOptions, request: requestOptions } = options
    ? options.mutation &&
      'mutationKey' in options.mutation &&
      options.mutation.mutationKey
      ? options
      : { ...options, mutation: { ...options.mutation, mutationKey } }
    : { mutation: { mutationKey }, request: undefined };

  const mutationFn: MutationFunction<
    Awaited<ReturnType<typeof authorsControllerRemove>>,
    { id: number }
  > = (props) => {
    const { id } = props ?? {};

    return authorsControllerRemove(id, requestOptions);
  };

  return { mutationFn, ...mutationOptions };
};

export type AuthorsControllerRemoveMutationResult = NonNullable<
  Awaited<ReturnType<typeof authorsControllerRemove>>
>;

export type AuthorsControllerRemoveMutationError = ErrorType<void>;

/**
 * @summary Delete author by ID
 */
export const useAuthorsControllerRemove = <
  TError = ErrorType<void>,
  TContext = unknown,
>(options?: {
  mutation?: UseMutationOptions<
    Awaited<ReturnType<typeof authorsControllerRemove>>,
    TError,
    { id: number },
    TContext
  >;
  request?: SecondParameter<typeof customInstance>;
}): UseMutationResult<
  Awaited<ReturnType<typeof authorsControllerRemove>>,
  TError,
  { id: number },
  TContext
> => {
  const mutationOptions = getAuthorsControllerRemoveMutationOptions(options);

  return useMutation(mutationOptions);
};
